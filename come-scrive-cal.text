---
title: "Il modo in cui Cal scrive"
layout: default
---

# Il modo in cui Cal. scrive
È un po' complicato ed ha avuto bisogno di un po' di tempo per arrivare al grado di collaudamento attuale. Esso si compone di diversi *software*, dal basso verso la tastiera:

LaTeX
  ~ Dovrebbe andare bene una distribuzione qualsiasi, a patto che pandoc sappia dove trovarla. Quindi deve trovarsi in `$PATH` e tutte le altre belle cose che il tuo sistema tenta di nasconderti.

Pandoc
  ~ Convertitore universale di documenti. Scaricabile [qui](http://johnmacfarlane.net/pandoc/installing.html).

`make`
  ~ Questo dovrebbe già essere su ogni sistema degno di questo nome. Su windows manca. Non ho idea di come possa essere sostituito; forse Cygwin lo implementa...

Emacs
  ~ Un intero sistema operativo al quale manca un editor decente, dicono i suoi detrattori. Questa è la parte meno fondamentale di tutte, a dir il vero. Usate l'editor che più vi piace.

<!-- ## Markdown 
Qui aggiungerò un'introduzione a Markdown, perché questo documento non può essere davvero completo senza.

-->

## Makefiles
I vari software una volta installati dovrebbero comunicare senza necessità di interventi ulteriori.

Il makefile, per il quale si ringraziano varie persone trovate prima o poi su google, che cal di solito invoca con `M-! make <RET>`, fa questa roba:

- elenca tutti i file `.text` nella dir in cui viene invocato, e
- sostituendo l'estensione genera una lista di target `.pdf` che poi
- compila con le opzioni scelte.

```{.make}
PANDOC = pandoc

PANVARS = --var=papersize:a4paper \
	--var=lang:italian 

FILES = $(patsubst %.text,%.pdf,$(wildcard *.text))

all: $(FILES)

%.pdf: %.text makefile
	$(PANDOC) $(PANVARS) -o $@ $< && open $@

%.tex: %.text makefile
	$(PANDOC) $(PANVARS) --standalone -o $@ $<
```

Ci potrebbero essere modifiche per supportare una bibliografia o inserire altra roba arbitraria nel preambolo, strumento che uso per includere `siunitx`, di solito, o per ridimensionare la dimensione massima delle immagini nei documenti. Per esempio:

```{.make}
PANDOC = pandoc

PANVARS = --var=papersize:a4paper \
	--var=lang:italian \
	--var=header-includes:'\frenchspacing\ifdefined\maxwidth\renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{\#1}}\fi' \
	--bibliography $*.bib

FILES = $(patsubst %.text,%.pdf,$(wildcard *.text))

all: $(FILES)

%.pdf: %.text makefile %.bib
	$(PANDOC) $(PANVARS) -o $@ $< && open $@

%.tex: %.text makefile %.bib
	$(PANDOC) $(PANVARS) --standalone -o $@ $<
```

Un altro makefile che Cal. vuole appuntare qui è questo, che, oltre a fare quanto descritto nei commenti con le immagini, evita di stampare sulla shell ciò che non è errore.

```{.make}
PANDOC = @pandoc
PANVARS = --var=papersize:a4paper \
	--var=lang:italian \
	--var=header-includes:'\usepackage{baskervald}\frenchspacing' \
	--var=header-includes:'\makeatletter\ifdefined\ScaleIfNeeded\def\ScaleIfNeeded{ \ifdim\Gin@nat@width>\linewidth\ifdim\Gin@nat@height>.75\Gin@nat@width .75\linewidth\else\linewidth\fi\else\Gin@nat@width\fi}\fi\makeatother' \
	--bibliography $*.bib 

#	Quella cosa lì molto lunga dice in pratica: 
# 	- se l'immagine è più larga della pagina, ridimensionala. però: 
#	  rendi larghe quanto la pagina immagini la cui altezza è al
#	  più .75 volte la loro altezza
# 	- se l'immagine è piccola, lasciala tale.

PIPE = > /dev/null

FILES = $(patsubst %.text,%.pdf,$(wildcard *.text))

all: $(FILES)

%.pdf: %.text makefile %.bib
	$(PANDOC) $(PANVARS) -o $@ $< $(PIPE) && open $@

%.tex: %.text makefile %.bib
	$(PANDOC) $(PANVARS) --standalone -o $@ $< $(PIPE)
```

## Emacs
`Markdown-mode` è abbastanza funzionante, se si ricorda di abilitare la matematica nei documenti `(setq markdown-enable-math t)`, mi pare; in modo che non tratti gli underscore dei pedici come comandi per corsivo, e se si affianca ad `adaptive-wrap`.

Un miglioramento notevole viene ottenuto cambiando il cursore di default di emacs ed impostando un po' di roba semplice nel `.emacs`:

- riconoscimento automatico delle estensioni per markdown;
- evidenziazione della riga corrente `hl-line-mode`;
- "a capo automatico" morbido `visual-line-mode`;
- font proporzionale (migliora **di molto** la leggibilità, quando non si tratta di codice) `variable-pitch-mode`.

```elisp
(delete-selection-mode 1) ; se cominci a scrivere con del testo selezionato, ciò che scrivi sostituisce la selezione

;; Markdown mode
(autoload 'markdown-mode "markdown-mode"
   "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.text\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

;; Text mode (applies to Markdown & LaTeX, too)
(add-hook 'text-mode-hook 'hl-line-mode)
(add-hook 'text-mode-hook 'adaptive-wrap-prefix-mode)
(add-hook 'text-mode-hook 'turn-on-visual-line-mode); a capo automatico
(add-hook 'text-mode-hook 'variable-pitch-mode); font proporzionale
```

### Correttore ortografico

*(NOTA BENE: questa cosa non funziona abbastanza da essere usata)*

Ho anche provato a configurare un correttore ortografico per supportarmi nella scrittura in emacs. Pare che il migliore disponibile sia *hunspell*. L'interfaccia di emacs, `ispell.el` supporta hunspell, ed hunspell ha una modalità di compatibilità con *ispell*. 

Dopo innumerevoli ricerche ed ore perse a tentare di configurare il tutto, con nessun cane che si fosse degnato di scrivere della documentazione su cosa fossero i campi delle "tuple" (come si chiamano queste cose in elisp?) di `ispell-dictionary-alist`, una casuale ricerca google mi porta al sorgente di ispell.el, che si documenta abbastanza bene (sebbene sia poco comprensibile il significato stesso della documentazione, è da dire); cosa che mi consente finalmente di scrivere le poche righe necessarie in `.emacs`:

```elisp
;; Ispell (really hunspell)
(require 'ispell)
(setq ispell-local-dictionary-alist
  '(("italian"
     "[A-Za-zàèéìòùÀÈÉÌÒÙ]" "[^A-Za-zàèéìòùÀÈÉÌÒÙ]" "[']" nil
     ("-d" "/Applications/LibreOffice.app/Contents/share/extensions/dict-it/it_IT") "~list" utf-8)))
(eval-after-load "ispell"
  (progn
    (setq ispell-dictionary "italian"
          ispell-extra-args '("-a" "-i" "utf-8")
          ispell-silently-savep t)))
(setq-default ispell-program-name "hunspell")
```

Imho il problema si trova da qualche parte fra huspell e gli affix file del dizionario italiano (che però in LibO funzionano, quindi non so davvero), in pratica, si impone di correggere il "quand" in "quand'è" rendendolo a sua volta un "quand'è," risultando con un testo contenente "quand'è'è."

Spero che qualcuno più esperto di me risolva questo problema.

## Cose da fare

- creare il famoso repo dei dotfiles a forza di symlink.
